a) I've used AES with CBC mode. As we are talking about a secure messaging algorithm, I've decided to go with a symmetrical key as latency does matter in the matters of communication.
(And more explained in part c) After deciding to use a symmetrical ciphering algorithm, AES with a strong key value made the most sense. For the mode, I've picked CBC as again a matter of good security.
While CBC can be slow when encrypting/decrypting large files due to the sequential nature of it, this should not be a concern as this will be used to exchange confidential messages, rather than large files.
b) I'm using 256 bits. Since we are talking about writing a secure/confidential messaging program, the assumption is while latency does matter,
making the system more secure is worth to make the service slightly less fast.
While 128 bit AES would be a good choice as well, 256 bits would be a safer bet against quantum computer attacks, which is becoming more a reality by each year.
c) This also ties to one of the reasons why I picked a symmetric key to begin with. As we've discussed in class, asymmetric keys can be slow, which is something we want to avoid if we can. Due to that, using a hybrid system would make a lot more sense.
Initial connection can be established with asymmetric key, with Diffie-Hellman key exchange. After the asymmetric key exchange, we would not just be sure of Confidentiality but of Integrity and Authentication. Then, one party can generate the session key, and share the key through the asymmetric channel.
Afterwards, the asymmetric connection can be severed and the messages can be sent being encrypted with the symmetric key that was implemented.
d) The source code lies in the generate function in hw2.py. It is really straightforward, asking the OS to generate a pseudo-random 32-byte byte value.
While sourcing the key from 'os.urandom' is not a great way, it is better than 'random.py'. The key reason is random.py requires a seed value, thus making it more deterministic.Python documentation approves of 'os.urandom' approves of 'os.urandom' to be applicable for cryptographic purposes. [Source, https://docs.python.org/2/library/os.html Section 15.1.7]
e) While the implemented&future implementation would be good, that's not the end of the story. First of all, there is still information leak even when the message is encrypted.
MITM would not be able to see the contents of the message, but they can still see 'communication happening'. If we are thinking about confidential messsaging for military use for example, even to see communication happening could be too much of a leak as it is.
Also, due to the implementation we save the key&iv on a file. Ideally we would not want this to happen, as it becomes an easier target as an attacker might not directly attack the process, but try to reside as a malicious process and read those files.
Another (huge) risk is networking aspect of this service. There could be the chance of DNS spoofing, or many other types of attacks we have not covered yet.
